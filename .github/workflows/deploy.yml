name: Deploy Super Mario Game to EKS

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      confirm_destroy:
        description: "Type 'yes' to confirm Terraform destroy"
        required: true
  delete:

jobs:
  deploy:
    runs-on: self-hosted

    env:
      AWS_REGION: us-east-1
      ECR_REPOSITORY: supermario-game
      CLUSTER_NAME: super-mario-eks
      TERRAFORM_DIR: terraform-files

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Configure AWS credentials
        run: |
          mkdir -p $HOME/.aws
          cat > $HOME/.aws/credentials << EOF
          [default]
          aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          EOF
          
          cat > $HOME/.aws/config << EOF
          [default]
          region=${{ env.AWS_REGION }}
          output=json
          EOF

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v1

      - name: Initialize Terraform
        run: |
          cd terraform-files
          terraform init

      - name: Destroy Terraform resources if requested
        if: ${{ github.event.inputs.confirm_destroy == 'yes' }}
        run: |
          cd terraform-files
          terraform destroy -auto-approve

      - name: Apply Terraform if not destroying
        if: ${{ github.event.inputs.confirm_destroy != 'yes' }}
        run: |
          cd terraform-files
          terraform apply -auto-approve

      - name: Configure ECR and build/push image
        if: ${{ github.event.inputs.confirm_destroy != 'yes' }}
        run: |
          # Create ECR repository if it doesn't exist
          if ! aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }}
          fi
          
          # Get ECR URI
          ECR_URI=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --query 'repositories[0].repositoryUri' --output text)
          
          # Build and push Docker image
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${ECR_URI}
          cd docker
          docker build -t ${{ env.ECR_REPOSITORY }}:latest .
          docker tag ${{ env.ECR_REPOSITORY }}:latest ${ECR_URI}:latest
          docker push ${ECR_URI}:latest

      - name: Deploy to Kubernetes
        if: ${{ github.event.inputs.confirm_destroy != 'yes' }}
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}
          cd k8s
          kubectl apply -f k8s-deployment.yml
          
          # Update the deployment with new image
          ECR_URI=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --query 'repositories[0].repositoryUri' --output text)
          kubectl set image deployment/supermario-game supermario-game=${ECR_URI}:latest
          kubectl rollout status deployment/supermario-game --timeout=180s
          
          echo "Deployment complete! Access your Super Mario game at:"
          kubectl get svc supermario-service -o jsonpath="{.status.loadBalancer.ingress[0].hostname}"