name: Deploy Super Mario Game to EKS

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      confirm_destroy:
        description: "Type 'yes' to confirm Terraform destroy"
        required: true
  delete:

jobs:
  deploy:
    runs-on: self-hosted

    env:
      AWS_REGION: us-east-1
      ECR_REPOSITORY: supermario-game
      CLUSTER_NAME: super-mario-eks
      TERRAFORM_DIR: terraform-files

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Install AWS CLI
        run: |
          if ! command -v aws &> /dev/null; then
            echo "Installing AWS CLI locally..."
            mkdir -p $HOME/aws-cli
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip -q awscliv2.zip
            ./aws/install --bin-dir $HOME/aws-cli/bin --install-dir $HOME/aws-cli/aws-cli
            echo "export PATH=$HOME/aws-cli/bin:$PATH" >> $HOME/.bashrc
            export PATH=$HOME/aws-cli/bin:$PATH
            rm -rf aws awscliv2.zip
            echo "AWS CLI installed successfully"
          else
            echo "AWS CLI already installed"
            aws --version
          fi

      - name: Install kubectl
        run: |
          if ! command -v kubectl &> /dev/null; then
            echo "Installing kubectl locally..."
            mkdir -p $HOME/bin
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            mv kubectl $HOME/bin/
            export PATH=$HOME/bin:$PATH
            echo "export PATH=$HOME/bin:$PATH" >> $HOME/.bashrc
            echo "kubectl installed successfully"
          else
            echo "kubectl already installed"
            kubectl version --client
          fi

      - name: Configure AWS credentials
        run: |
          mkdir -p $HOME/.aws
          cat > $HOME/.aws/credentials << EOF
          [default]
          aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          EOF
          
          cat > $HOME/.aws/config << EOF
          [default]
          region=${{ env.AWS_REGION }}
          output=json
          EOF
          
          export PATH=$HOME/aws-cli/bin:$PATH
          aws sts get-caller-identity || {
            echo "Error: AWS credentials verification failed"
            exit 1
          }

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: "1.0.0"

      - name: Initialize Terraform
        run: |
          if [ ! -d "terraform-files" ]; then
            echo "Error: terraform-files directory not found!"
            ls -la
            exit 1
          fi
          cd terraform-files
          terraform init || {
            echo "Error: Terraform initialization failed"
            exit 1
          }

      - name: Destroy Terraform resources if requested
        if: ${{ github.event.inputs.confirm_destroy == 'yes' }}
        run: |
          cd terraform-files
          echo "Starting Terraform destroy..."
          terraform destroy -auto-approve || {
            echo "Error: Terraform destroy failed"
            exit 1
          }
          echo "Terraform destroy completed successfully"

      - name: Apply Terraform if not destroying
        if: ${{ github.event.inputs.confirm_destroy != 'yes' }}
        run: |
          cd terraform-files
          echo "Starting Terraform apply..."
          terraform apply -auto-approve || {
            echo "Error: Terraform apply failed"
            exit 1
          }
          echo "Waiting for infrastructure to be ready..."
          sleep 30  # Give time for EKS cluster to stabilize

      - name: Configure ECR and build/push image
        if: ${{ github.event.inputs.confirm_destroy != 'yes' }}
        run: |
          export PATH=$HOME/aws-cli/bin:$PATH
          echo "Setting up ECR repository..."
          if ! aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "Creating ECR repository..."
            aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }}
          fi
          
          ECR_URI=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --query 'repositories[0].repositoryUri' --output text)
          echo "ECR URI: $ECR_URI"
          
          if [ ! -d "docker" ]; then
            echo "Error: docker directory not found!"
            ls -la
            exit 1
          fi
          
          echo "Logging into ECR..."
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${ECR_URI}
          
          echo "Building Docker image..."
          cd docker
          docker build -t ${{ env.ECR_REPOSITORY }}:latest .
          docker tag ${{ env.ECR_REPOSITORY }}:latest ${ECR_URI}:latest
          
          echo "Pushing image to ECR..."
          docker push ${ECR_URI}:latest

      - name: Deploy to Kubernetes
        if: ${{ github.event.inputs.confirm_destroy != 'yes' }}
        run: |
          export PATH=$HOME/bin:$PATH
          export PATH=$HOME/aws-cli/bin:$PATH
          
          echo "Configuring kubectl..."
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}
          
          if [ ! -d "k8s" ]; then
            echo "Error: k8s directory not found!"
            ls -la
            exit 1
          fi
          
          cd k8s
          echo "Applying Kubernetes configurations..."
          kubectl apply -f k8s-deployment.yml
          
          echo "Updating deployment with new image..."
          ECR_URI=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --query 'repositories[0].repositoryUri' --output text)
          kubectl set image deployment/supermario-game supermario-game=${ECR_URI}:latest
          
          echo "Waiting for deployment to complete..."
          kubectl rollout status deployment/supermario-game --timeout=180s
          
          echo "Getting service URL..."
          HOSTNAME=$(kubectl get svc supermario-service -o jsonpath="{.status.loadBalancer.ingress[0].hostname}")
          echo "Service is available at: $HOSTNAME"