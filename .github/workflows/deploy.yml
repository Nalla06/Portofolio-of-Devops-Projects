name: Deploy Super Mario Game to EKS

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      confirm_destroy:
        description: "Type 'yes' to confirm Terraform destroy"
        required: true
  delete:

jobs:
  deploy:
    runs-on: self-hosted

    env:
      AWS_REGION: us-east-1
      ECR_REPOSITORY: supermario-game
      CLUSTER_NAME: super-mario-eks
      TERRAFORM_DIR: terraform-files

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      # Set up AWS credentials in environment variables
      # This avoids AWS CLI PATH issues
      - name: Set AWS credentials as environment variables
        run: |
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV
          echo "AWS_DEFAULT_REGION=${{ env.AWS_REGION }}" >> $GITHUB_ENV
          echo "AWS credentials configured as environment variables"

      - name: Setup basic tools
        run: |
          echo "Setting up utilities needed for deployment..." 
          
          # Verify where AWS CLI is available (don't install yet)
          AWS_PATH=$(which aws || echo "not-found")
          echo "AWS CLI path: $AWS_PATH"
          
          # Set path to include expected AWS CLI locations
          export PATH=$PATH:$HOME/aws-cli/v2/2.24.7/dist:$HOME/bin:/usr/local/bin
          echo "Updated PATH: $PATH"

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v1

      # Find Terraform directory
      - name: Locate Terraform directory
        id: find-terraform
        run: |
          if [ -d "${{ env.TERRAFORM_DIR }}" ]; then
            echo "terraform_path=${{ env.TERRAFORM_DIR }}" >> $GITHUB_OUTPUT
          else
            TF_PATH=$(find . -type d -name "terraform-files" | head -n 1)
            if [ -n "$TF_PATH" ]; then
              echo "terraform_path=$TF_PATH" >> $GITHUB_OUTPUT
            else
              echo "ERROR: terraform-files directory not found."
              exit 1
            fi
          fi

      # Initialize Terraform
      - name: Initialize Terraform
        run: |
          cd ${{ steps.find-terraform.outputs.terraform_path }}
          terraform init

      # Handle manual destroy operation
      - name: Manual Terraform destroy
        if: ${{ github.event.inputs.confirm_destroy == 'yes' }}
        run: |
          cd ${{ steps.find-terraform.outputs.terraform_path }}
          
          # First remove node groups
          echo "Removing EKS node groups first..."
          terraform destroy -auto-approve -target="aws_eks_node_group.eks_nodes" || echo "No node groups or already destroyed"
          
          # Then remove EKS cluster
          echo "Removing EKS cluster..."
          terraform destroy -auto-approve -target="aws_eks_cluster.eks" || echo "No EKS cluster or already destroyed"
          
          # Finally destroy everything else
          echo "Destroying remaining resources..."
          terraform destroy -auto-approve
          
          echo "Terraform resources destroyed successfully."
          exit 0

      # Apply Terraform first - important change in sequence
      - name: Apply Terraform
        id: terraform-apply
        run: |
          cd ${{ steps.find-terraform.outputs.terraform_path }}
          terraform apply -auto-approve
          
          # Export the ECR repository URL for later use
          # This avoids needing AWS CLI for this specific operation
          ECR_URI=$(terraform output -raw ecr_repository_url || echo "")
          if [ -n "$ECR_URI" ]; then
            echo "ECR_URI=$ECR_URI" >> $GITHUB_OUTPUT
            echo "terraform_success=true" >> $GITHUB_OUTPUT
          else
            # Try to get it from AWS CLI if terraform output isn't available
            export PATH=$PATH:$HOME/aws-cli/v2/2.24.7/dist
            if command -v aws &> /dev/null; then
              ECR_URI=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --query 'repositories[0].repositoryUri' --output text 2>/dev/null || echo "")
              if [ -n "$ECR_URI" ]; then
                echo "ECR_URI=$ECR_URI" >> $GITHUB_OUTPUT
              fi
            fi
            echo "terraform_success=true" >> $GITHUB_OUTPUT
          fi

      # Now set up Kubernetes tools since infrastructure exists
      - name: Ensure kubectl is available
        if: steps.terraform-apply.outputs.terraform_success == 'true'
        run: |
          if ! command -v kubectl &> /dev/null; then
            echo "kubectl not found, installing to user directory..."
            mkdir -p $HOME/bin
            curl -LO "https://dl.k8s.io/release/v1.25.0/bin/linux/amd64/kubectl"
            chmod +x kubectl
            mv kubectl $HOME/bin/
            export PATH=$HOME/bin:$PATH
            echo "kubectl installed to $HOME/bin"
          fi
          echo "kubectl version:"
          PATH=$PATH:$HOME/bin kubectl version --client

      - name: Update kubeconfig for EKS
        if: steps.terraform-apply.outputs.terraform_success == 'true'
        run: |
          export PATH=$PATH:$HOME/aws-cli/v2/2.24.7/dist:$HOME/bin
          echo "Configuring kubeconfig for ${{ env.CLUSTER_NAME }}..."
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}

      # Check Docker availability 
      - name: Check if Docker is available
        id: check-docker
        if: steps.terraform-apply.outputs.terraform_success == 'true'
        run: |
          if command -v docker &> /dev/null; then
            echo "docker_available=true" >> $GITHUB_OUTPUT
          else
            echo "WARNING: Docker is not available on this runner."
            echo "docker_available=false" >> $GITHUB_OUTPUT
          fi

      # Build and push Docker image
      - name: Build and push Docker image
        id: docker-build
        if: steps.terraform-apply.outputs.terraform_success == 'true' && steps.check-docker.outputs.docker_available == 'true'
        run: |
          # Find Docker directory
          if [ -d "docker" ]; then
            DOCKER_DIR="docker"
          else
            DOCKER_DIR=$(find . -type d -name "docker" | head -n 1)
          fi
          
          if [ -n "$DOCKER_DIR" ] && [ -n "${{ steps.terraform-apply.outputs.ECR_URI }}" ]; then
            cd "$DOCKER_DIR"
            echo "Building Docker image in $(pwd)"
            
            # Get ECR login token using path to AWS CLI
            export PATH=$PATH:$HOME/aws-cli/v2/2.24.7/dist
            aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $(echo "${{ steps.terraform-apply.outputs.ECR_URI }}" | cut -d'/' -f1)
            
            # Build and push image
            docker build -t ${{ env.ECR_REPOSITORY }}:latest . && \
            docker tag ${{ env.ECR_REPOSITORY }}:latest ${{ steps.terraform-apply.outputs.ECR_URI }}:latest && \
            docker push ${{ steps.terraform-apply.outputs.ECR_URI }}:latest && \
            echo "docker_success=true" >> $GITHUB_OUTPUT || echo "docker_success=false" >> $GITHUB_OUTPUT
          else
            echo "ERROR: Docker directory not found or ECR URI not available."
            echo "docker_success=false" >> $GITHUB_OUTPUT
          fi

      # Deploy to Kubernetes
      - name: Deploy to Kubernetes
        id: k8s-deploy
        if: steps.terraform-apply.outputs.terraform_success == 'true'
        run: |
          export PATH=$PATH:$HOME/aws-cli/v2/2.24.7/dist:$HOME/bin
          
          # Find K8s directory
          if [ -d "k8s" ]; then
            K8S_DIR="k8s"
          else
            K8S_DIR=$(find . -type d -name "k8s" | head -n 1)
          fi
          
          if [ -n "$K8S_DIR" ]; then
            cd "$K8S_DIR"
            echo "Applying K8s configs in $(pwd)"
            
            PATH=$PATH:$HOME/bin kubectl apply -f k8s-deployment.yml
            
            # Update the image if Docker was successful
            if [ "${{ steps.check-docker.outputs.docker_available }}" == "true" ] && [ "${{ steps.docker-build.outputs.docker_success }}" == "true" ]; then
              echo "Updating container image to ${{ steps.terraform-apply.outputs.ECR_URI }}:latest"
              PATH=$PATH:$HOME/bin kubectl set image deployment/supermario-game supermario-game=${{ steps.terraform-apply.outputs.ECR_URI }}:latest
              
              echo "Waiting for deployment to complete..."
              PATH=$PATH:$HOME/bin kubectl rollout status deployment/supermario-game --timeout=180s
              echo "k8s_success=true" >> $GITHUB_OUTPUT
            else
              echo "WARNING: Skipping image update, using default image from deployment manifest"
              echo "k8s_success=true" >> $GITHUB_OUTPUT
            fi
            
            echo "Deployment complete! Access your Super Mario game at:"
            PATH=$PATH:$HOME/bin kubectl get svc supermario-service -o jsonpath="{.status.loadBalancer.ingress[0].hostname}"
          else
            echo "ERROR: k8s directory not found."
            echo "k8s_success=false" >> $GITHUB_OUTPUT
          fi

      # Terraform output (for debugging)
      - name: Display Terraform outputs
        if: always()
        run: |
          cd ${{ steps.find-terraform.outputs.terraform_path }}
          echo "Terraform outputs:"
          terraform output || echo "No outputs available"

      # Cleanup only if deployment fails after Terraform apply
      - name: Cleanup on deployment failure
        if: failure() && steps.terraform-apply.outputs.terraform_success == 'true'
        run: |
          echo "Deployment failed after infrastructure was created. Cleaning up resources..."
          cd ${{ steps.find-terraform.outputs.terraform_path }}
          
          # Try to drain nodes if kubectl is available
          export PATH=$PATH:$HOME/bin
          if command -v kubectl &>/dev/null; then
            echo "Attempting to drain nodes..."
            kubectl get nodes -o name 2>/dev/null | xargs -r -I{} kubectl drain {} --delete-emptydir-data --force --ignore-daemonsets --timeout=60s 2>/dev/null || true
          fi
          
          # Destroy resources in order
          echo "Destroying infrastructure..."
          terraform destroy -auto-approve -target="aws_eks_node_group.eks_nodes" || true
          terraform destroy -auto-approve -target="aws_eks_cluster.eks" || true
          terraform destroy -auto-approve
          
          echo "Cleanup complete."